/*
 * Isomorphic SmartClient
 * Version SC_SNAPSHOT-2010-03-13 (2010-03-13)
 * Copyright(c) 1998 and beyond Isomorphic Software, Inc. All rights reserved.
 * "SmartClient" is a trademark of Isomorphic Software, Inc.
 *
 * licensing@smartclient.com
 *
 * http://smartclient.com/license
 */
//> @class AutoTest
// Standalone class providing a general interface for integration with Automated Testing Tools
// @visibility autoTest
//<
// Need to add @treeLocation 


// Overview
//
// For automated testing tools we need a way to identify a DOM element as a string such that 
// when a page is reloaded, we can retrieve a functionally equivalent DOM element from that
// string.
// This allows automated testing tools to set up or record user generated events on DOM elements
// then play them back on page reload and have our components react correctly.

// Considerations:
// - Some components react to the structure of DOM elements embedded within them - for example
//   GridRenderer cells have meaning to the grid. So in some cases we need to identify elements
//   within a component, while in others we can just return a pointer to a handle (A simple
//   canvas click handler doesn't care about what native DOM element within the  handle received
//   the click).
//
// - when a DOM element is contained by a component, it is not sufficient to store the component
//   ID. Most SmartClient components are auto-generated by their parents, and rather than 
//   attempting to store a specific component identifier we should instead store the
//   "logical function" of the component. 
//   For example a listGrid header button may have a different auto-generated ID across page
//   reloads due to unrelated timing issues (order of widget creation), loading a new skin, 
//   etc.  Rather than storing the header button ID therefore, we want to store this as
//   a string meaning "The header button representing field X within this list grid".
//
// - fallback strategies: In the locator string, capture all information that
//   might be relevant/useful in looking up the component or element.  We'll have override
//   points and mode flags you can set on components for which parts of the locator string are
//   actually *preferred* during component/element lookup, but we want to capture lots of
//   information so that we can use fallback strategies as needed
//   For example, for ListGrid cells, we support looking up rows by index or by the 
//   data contained in the record (primary key, etc).



isc.defineClass("AutoTest");


//> @type Locator
// String used by SmartClient to identify an interactive area on the screen without reference
// to specific DOM elements.  Needed since the DOM element that SmartClient uses to render
// the UI can differ across browsers, across versions of SmartClient, and in different skins.
//
// The format of the locator is considered internal to SmartClient.
//<



isc.AutoTest.addClassMethods({
    
    //> @classMethod AutoTest.getLocator()
    // Returns the +link{type:Locator} associated with some DOM element. 
    // @param (DOMElement) DOM element somewhere in the page
    // @return (Locator) abstract Locator String
    // @visibility autoTest 
    //<
    getLocator : function (DOMElement) {
        var canvas;
        if (isc.isA.Canvas(DOMElement)) canvas = DOMElement;
        else {
            canvas = isc.AutoTest.locateCanvasFromDOMElement(DOMElement);            
        }
        return canvas ? canvas.getLocator(DOMElement) : "";
    },
    locateCanvasFromDOMElement : function (element) {
        
        return isc.EH.getEventTargetCanvas(null, element);
    },
    
        
    // ------------------------------
    // Retrieving elements from the DOM based on locator string
    //> @classMethod AutoTest.getElement()
    // @param (Locator) Locator String previously returned by +link{AutoTest.getLocator()}
    // @return (DOMElement) DOM element this locator refers to in the running application, or
    // null if not found
    // @visibility autoTest
    //<
    
    getElement : function (locator) {
        if (!locator) return null;
        var locatorArray = locator.split("/"),
            component;
        //this.logWarn("locatorArray" + locatorArray);
        // account for the 2 slashes
        var baseComponentID = locatorArray[2];
        
        // knock off the first 3 slots
        var length = locatorArray.length;
        for (var i = 3; i < length; i++) {
            locatorArray[i-3] = locatorArray[i];
        }
        locatorArray.length = length-3;        
        if (!baseComponentID) return null;
        
        var baseComponent = this.getComponentFromLocatorSubstring(baseComponentID);
        return baseComponent ? baseComponent.getElementFromSplitLocator(locatorArray) : null;
    },
    
    
    getComponentFromLocatorSubstring : function (substring) {
        var className = substring.match("(.*)\\[")[1],
            ID = substring.match('ID=\\"(.*)\\"')[1];
        //this.logWarn("className/ID:" + [className,ID]);
        
        var baseComponent = window[ID];
        if (!baseComponent) return null;
        if (baseComponent && (!isc.isA[className] || !isc.isA[className](baseComponent))) {
            this.logWarn("AutoTest.getElement(): Component:"+ baseComponent + 
                        " expected to be of class:" + className);
        }
        return baseComponent;
    },
    
     // Retrieving SC objects from locator string
    //> @classMethod AutoTest.getLocatorCanvas()
    // Returns the Canvas for some previously generated locator string.
    // @param (Locator) Locator String previously returned by +link{AutoTest.getLocator()}
    // @return (Canvas) Canvas associated with this locator
    // @visibility autoTest
    //<
    getLocatorCanvas : function (locator) {
        
                
        // Simply get the DOM element and pick up the Canvas from it.
        // XXX this will not work if the Canvas is currently undrawn.
        /*
        var DOMElement = this.getElement(locator);
        if (DOMElement != null) {
            return this.locateCanvasFromDOMElement(DOMElement);
        }
        return null;
        */
        
        if (locator == null || isc.isAn.emptyString(locator)) return null;
        var locatorArray = locator.split("/"),
            component;
        //this.logWarn("locatorArray" + locatorArray);
        // account for the 2 slashes
        var baseComponentID = locatorArray[2];
        
        // knock off the first 3 slots
        var length = locatorArray.length;
        for (var i = 3; i < length; i++) {
            locatorArray[i-3] = locatorArray[i];
        }
        locatorArray.length = length-3;
        if (!baseComponentID) return null;
        
        var baseComponent = this.getComponentFromLocatorSubstring(baseComponentID);
        if (baseComponent) {
            var i = 0,
                child = baseComponent.getChildFromLocatorSubstring(locatorArray[i]);
            while (child != null) {
                i++;
                baseComponent = child;
                child = baseComponent.getChildFromLocatorSubstring(locatorArray[i]);
            }
            return baseComponent;
        }
        return null;
    },
    
    //> @classMethod AutoTest.getLocatorFormItem()
    // Returns the FormItem for some previously generated locator string, or null if no
    // matching FormItem can be found.
    // @param (Locator) Locator String previously returned by +link{AutoTest.getLocator()}
    // @return (Canvas) Canvas associated with this locator
    // @visibility autoTest
    //<
    getLocatorFormItem : function (locator) {
              
        // Simply get the DOM element and pick up the DynamicForm/ FormItem from it.
        // XXX this will not work if the Canvas is currently undrawn.
        /*
        var DOMElement = this.getElement(locator);
        if (DOMElement != null) {
            var form = this.locateCanvasFromDOMElement(DOMElement);
            if (isc.isA.DynamicForm(form)) {
                var itemInfo = isc.DynamicForm._getItemInfoFromElement(DOMElement,form);
                if (itemInfo) return itemInfo.item;
            }
        }
        return null;
        */
            
        if (locator == null || isc.isAn.emptyString(locator)) return null;
        var locatorArray = locator.split("/"),
            component;
        // account for the 2 slashes
        var baseComponentID = locatorArray[2];
        
        // knock off the first 3 slots
        var length = locatorArray.length;
        for (var i = 3; i < length; i++) {
            locatorArray[i-3] = locatorArray[i];
        }
        locatorArray.length = length-3;
        if (!baseComponentID) return null;
        
        var baseComponent = this.getComponentFromLocatorSubstring(baseComponentID);
        if (baseComponent) {
            
            var child = baseComponent.getChildFromLocatorSubstring(locatorArray[0]);
            while (child != null) {
                locatorArray.removeAt(0);
                baseComponent = child;
                child = baseComponent.getChildFromLocatorSubstring(locatorArray[0]);
            }
        }
        if (isc.isA.DynamicForm(baseComponent)) {
            return baseComponent.getItemFromSplitLocator(locatorArray);
        }
        return null;
    },
    
    // Fallback locator subsystem:
    // For cases where there is more than one possible way to identify a component or element
    // we generate a string similar to this:
    // "row[a=b||b=c||7]"
    
    // createLocatorFallbackPath()
    // Takes a locator name and an object of the format:
    //   {fieldName:value, fieldName:value}
    // and returns a string in the format
    //   name[fieldName=value||fieldName=value...]
    // standalone values (with no "=" may also be included -- to do this set the "fallback_valueOnlyField"
    // property on the object passed in
    // For example:
    //   var identifier = {a:"b"};
    //   identifier[isc.AutoTest.fallback_valueOnlyField] = "c";
    //   isc.AutoTest.createLocatorFallbackPath("test", identifier);
    // would give back:
    //   "test[a:b||c]"
    
    fallback_valueOnlyField:"_$_standaloneProperty",
    
    fallback_startMarker:"[",
    fallback_endMarker:"]",
    fallback_separator:"||",
    fallback_equalMarker:"=",
    
    createLocatorFallbackPath : function (name, config) {
        
        var locator = [];
        
        for (var field in config) {
            if (field == this.fallback_valueOnlyField) {
                locator.add(config[field]);
            } else {
                locator.add(field + this.fallback_equalMarker + config[field]);
            }
        }
        return name + this.fallback_startMarker + locator.join(this.fallback_separator) + 
                    this.fallback_endMarker;
    },
    
    // This method will take a generated locatorFallbackPath string and return a
    // standard config object as described above - property/field values will be unmapped
    // and any standalone value will be stored under the special
    // isc.AutoTest.fallback_valueOnlyField attribute name.
    parseLocatorFallbackPath : function (path) {
        var pathArr = path.split(this.fallback_startMarker);
        // don't crash if we were passed something we don't understand...
        if (pathArr == null || pathArr.length < 2) return;
        
        var name = pathArr[0],
            path = pathArr[1].substring(0, pathArr[1].length-this.fallback_endMarker.length);
            
        var configArr = path.split(this.fallback_separator),
            configObj = {};
        for (var i = 0; i < configArr.length; i++) {
            var string = configArr[i],
                equalsIndex = string.indexOf(this.fallback_equalMarker);
                
            if (equalsIndex == -1) {
                configObj[this.fallback_valueOnlyField] = string;
            } else {
                configObj[string.substring(0,equalsIndex)] = string.substring(equalsIndex+1);
            }
        }
        
        // BackCompat: Standard locator format (pre March 2010) was always of the format
        // item[1][Class="Canvas"]
        // This is still used where we don't run through the fallback-path subsystem but is
        // being incrementally replaced.
        // If we're passed a string of that format, pull the class out of the string passed in
        // and attach it to the config object.
        // This means that for any old auto-test recordings with the previous identifier format
        // if they end up running through this subsystem we should still have predictable results
        if (pathArr[2] != null) {
            var string = pathArr[2].substring(0, pathArr[2].length-this.fallback_endMarker.length),
                equalsIndex = string.indexOf(this.fallback_equalMarker),
                
                key = string.substring(0,equalsIndex),
                val = string.substring(equalsIndex+1);
            // if the string was quoted, eat the quotes!
            if (val.startsWith('"')) val = val.substring(1, val.length-1);
            
            configObj[key] = val; 
        }
        
        return {name:name, config:configObj};
    },
    
    
    
    // Generate a standard object "locator fallback path" identifier from an object,
    // similar to:
    //  member[title="foo"||index=1||Class="ImgButton"]
    //
    // Parameters:
    // - name attribute specifies the identifier type (in this example "member")
    // - canvas is the object to get an identifier for
    // - properties is an object specifying some default identifier properties to use which
    //   cannot be directly retrieved from the object. Typically used to specify the
    //   index of the object in the named array.
    // - mask is an object or array specifying properties to include in the locator string.
    //   If an array of strings, for each element store the same-named attribute from the object
    //   on the locator string
    //   If an object, for each entry, pick up the value field from the object and store it
    //   under the key on the locator string
    // * When getting properties from the object, use getters if present
    // * if AutoTest.fallback_valueOnlyField is included this will be included in the 
    //   locator string with no key - for example
    //   member[1]
    //
    
    getObjectLocatorFallbackPath : function (name, object, properties, mask) {
        
        if (properties == null) properties = {};
      
        if (mask == null) mask = {
            title:"title",
            // we do this because widget.getClass() gives us the class object whereas
            // widget.getClassName gives us the name of the smartclient class...
            Class:"ClassName"
        };
        
        if (isc.isAn.Array(mask)) {
                
            for (var i = 0; i < mask.length; i++) {
                var value = object.getProperty ? object.getProperty(mask[i]) : object[mask[i]];
                if (value != null && !isc.isAn.emptyString(value)) properties[mask[i]] = value;
            }
        } else {
            for (var field in mask) {
                var value = object.getProperty ? object.getProperty(mask[field]) : object[mask[field]];
                if (value != null && !isc.isAn.emptyString(value)) properties[field] = value;
            }
        }
        
        // This will turn that config object into a standard locator type string.
        return isc.AutoTest.createLocatorFallbackPath(name, properties);
    },
    
    
    // Auto Test locators use various strategies to attempt to locate widgets. In some cases
    // we return a "best guess" type locator string -- for example an index in the members array
    // of a layout -- this is prone to return the wrong element if the page is restructured.
    // When actually retrieving elements from the DOM, we have some hints as to the fact that
    // our locator may be returning the wrong thing -- number of matching elements has changed
    // might be one of them, or the role / class of the widget we think matches is different
    // from what we recorded.
    // In these cases we'll log a warning.
    // This is a generic warning text which we can append to these warnings about how to
    // make identifying more robust in the future
    robustLocatorWarning:"If you are seeing unexpected results in recorded tests, it is likely" +
    " that the application has been modified since the test was recorded. We would recommend re-recording" +
    " your test script with the latest version of your application. Note that you may be able to" +
    " avoid seeing this message in future by using the AutoChild subsystem or providing explicit" +
    " global IDs to components whose function within the page is unlikely to change.",
    logRobustLocatorWarning : function () {
        if (this._loggedWarning) return;
        this.logWarn(this.robustLocatorWarning, "AutoTest");
        this._loggedWarning = true;
    }
        

});

isc.ApplyAutoTestMethods = function () {

isc.Canvas.addMethods({
    
    //> @method canvas.getLocator()
    // Get an abstract Locator String for an element contained within this Canvas
    // @param (DOMElement) DOM element contained within this Canvas
    // @return (Locator) abstract Locator String
    // @visibility autoTest
    //<
    getLocator : function (element) {
        var baseLocator, parent;
        if (this._generated || this.locatorParent || this.creator || this._autoAssignedID) {
            parent = this.getLocatorParent();
        }
        if (!parent) {
            baseLocator = this.getLocatorRoot();
        } else {
            baseLocator = parent.getLocator() + "/" +
                          parent.getChildLocator(this);
        }
        if (element) return [baseLocator, this.getInteriorLocator(element)].join("/");
        return baseLocator;
    },
    
    _locatorRootTemplate:[
    "//",
    ,   // classname
    '[ID="',
    ,   // global ID
    '"]'
    ],
    getLocatorRoot : function () {
        if (!this.locatorRoot) {
            this._locatorRootTemplate[1] = this.getClassName();
            this._locatorRootTemplate[3] = this.getID();
            this.locatorRoot = this._locatorRootTemplate.join(isc.emptyString);
        }
        return this.locatorRoot;
    },
    
    containsLocatorChild : function (canvas) {
        if (this.namedLocatorChildren != null) {
            for (var i = 0; i < this.namedLocatorChildren.length; i++) {
                var name = this.namedLocatorChildren[i];
                if (canvas == this[name]) {
                    return true;
                }
            }
        }
        return false;
    },
    
    getLocatorParent : function () {
        // locatorParent -- this is a generic entry point allowing special locator parent/child
        // behavior. 
        // To make use of this a widget could set itself as the locatorParent of some other
        // widget, and implement custom 'containsLocatorChild()' / 'getChildLocator()'  
        if (this.locatorParent && this.locatorParent.containsLocatorChild(this)) {
            return this.locatorParent;
        }
        if (this.creator && isc.isA.Canvas(this.creator)) {
            var autoChildName = this.creator.getAutoChildLocator(this);
            if (autoChildName == null) {
                // failed to find the child - most likely created via 'createAutoChild' but
                // never ran through addAutoChild() which would make it detectable in the
                // getAutoChildLocator() method
                // This is likely to happen if we are using the auto-child system to create
                // numerous auto-children with common properties, so it's not really a
                // failure.
                // Allow this to continue through the standard master-peer / parent-child
                // logic.
                this.logInfo("Locator code failed to find relationship between parent:"+
                            this.creator.getID() + " and autoChild:"+ this.getID(), "AutoTest");
            } else {
                return this.creator;
            }
        }
        return this.masterElement || this.parentElement;
    },
    
  
    //> @method canvas.getChildLocator()
    // Get the abstract Locator string for finding a child canvas within its parent element 
    // @param (Canvas)
    // @return (Locator) abstract Locator String for finding this child
    //<
    // Leave this internal - developers would call getLocator() directly
    _childLocatorTemplate:[
        ,   // "child" or "peer"
        "[",
        ,   // index of child/peer
        '][Class="',
        ,   // className of child/peer
        '"]'
    ],
     
    
    getChildLocator : function (canvas) {
        // special case scrollbars
        if (canvas == this.hscrollbar) {
            return "hscrollbar";
        }
        if (canvas == this.vscrollbar) {
            return "vscrollbar";
        }
        
        // More general behavior split into 2 parts for easy overriding - autoChildren are pretty
        // much always respected over other locators such as children / members array
        if (canvas.creator == this) {    
            var autoChildID = this.getAutoChildLocator(canvas);
            if (autoChildID) return autoChildID;
        }
        
        return this.getStandardChildLocator(canvas);
    },
    
    // getCanvasLocatorFallbackPath
    // generates a standard 'fallback path' to locate a widget from within a pool of widgets.
    // Used for locating mutliple auto children with the same name, members, peers, children
    // and so on.
    // The concept is that this'll capture as much information as possible so we can
    // use fallback strategies to get at the right object from a stored path.
    getCanvasLocatorFallbackPath : function (name, canvas, sourceArray, properties, mask) {
        
        if (properties == null) properties = {};
        
        if (mask == null) mask = {};
        else if (isc.isAn.Array(mask)) {
            var maskObj = {};
            for (var i = 0; i <mask.length; i++) {
                maskObj[mask[i]] = mask[i];
            }
            mask = maskObj;
        }
        
        // Always pick up the following attributes directly from the widget, if present
        if (mask.title == null) mask.title = "title";
        if (mask.scRole == null) mask.scRole = "waiRole";
        if (mask.name == null) mask.name = "name";
        
        // ClassName / scClassName - this is more complex than just looking at attributes on
        // the widget:
        // We need to pick up the class name, and if that's not a core smartclient class, also
        // pick up the core superclass of that class so we can look at both
        var objectClassName = canvas.getClassName(),
            objectClass = canvas.getClass();
        
        properties.Class = objectClassName;
        
        var scClassName;
        if (!objectClass.isFrameworkClass) {
            scClassName = objectClass._scClassName;
        }
        if (scClassName != null) properties.scClass = scClassName;
        
        
        // We also want to pick up index-based locators from the source array
        // Record both the index and the current length
        // Locating by index is always imperfect: If a developer changes the orders of
        // members (for example), it'll break.
        // However if the length is different when a recorded locator is parsed, we have
        // a really good indication that the index based locator is probably unreliable.
        if (sourceArray != null) {
            
            // Raw position in the array
            properties.index = sourceArray.indexOf(canvas);
            properties.length = sourceArray.length;

            // position within widgets of this class in the array
            // Use case: the developer adds something like a 'status label' at the top
            // of an array of buttons
            var matchingClass = sourceArray.findAll("Class", objectClassName);
            properties.classIndex = matchingClass.indexOf(canvas);
            properties.classLength = matchingClass.length;

            // position within widgets of this SmartClient class in the array
            // Use case: The developer subclasses a SmartClient component as the app matures
            // but the application layout stays the same, so an array of buttons becomes
            // an array of custom button subclasses
            if (scClassName != null) {
                var matchingSCClass = sourceArray.findAll("_scClass", scClassName);
                properties.scClassIndex = matchingSCClass.indexOf(canvas);
                properties.scClassLength = matchingSCClass.length;
            }
            
            // Position within widgets with this role in the warray
            // Use case: The smart client class changes due to (say) reskinning (moving from
            // a button to a stretchImgButton), but the role is unchanged
            if (canvas.waiRole != null) {
                var matchingRoles = sourceArray.findAll("waiRole", canvas.waiRole);
                properties.roleIndex = matchingRoles.indexOf(canvas);
                properties.roleLength = matchingRoles.length;
            }
        }
        
        return isc.AutoTest.getObjectLocatorFallbackPath(name, canvas, properties, mask);
    },
    
    
    getAutoChildLocator : function (canvas) {
        
        if (this._createdAutoChildren) {
            var ID = canvas.getID();
            for (var childName in this._createdAutoChildren) {
                var children = this._createdAutoChildren[childName];
                if (children.contains(ID)) {
                    // common case this.header etc
                    if (canvas == this[childName]) return childName;
                    else {
                        // create an array of the *live* auto children (not just their IDs)
                        // this allows us to figure out our index in that array as well as
                        // our index based on role!
                        var liveChildren = [];
                        for (var i = 0; i < children.length; i++) {
                            liveChildren[i] = window[children[i]];
                        }
                        
                        return this.getCanvasLocatorFallbackPath(childName, canvas, liveChildren);
                        
                    }
                }
            }
        }
        return null
    },
    
    getNamedLocatorChildString : function (canvas) {
         
        // Fairly common pattern - this.<someAttribute> is set directly to the canvas
        // but for whatever reason it didn't go through the addAutoChild() subsystem.
        // We can handle this explicitly by:
        // - setting locatorParent on the child to point to this widget
        // - adding an entry to the "namedLocatorChildren" array with the attribute name
        if (canvas.locatorParent == this && this.namedLocatorChildren) {
            for (var i = 0; i < this.namedLocatorChildren.length; i++) {
                var name = this.namedLocatorChildren[i];
                if (canvas == this[name]) {
                    return name;
                }
            }
        }
    },
    
    getStandardChildLocator : function (canvas) {
        var nlcs = this.getNamedLocatorChildString(canvas);
        if (nlcs) return nlcs;
       
        
        if (canvas.masterElement == this) {
            return this.getCanvasLocatorFallbackPath("peer", canvas, this.peers);
            
        } else if (canvas.parentElement == this) {
            return this.getCanvasLocatorFallbackPath("child", canvas, this.children);
        } else {
            // Not clear what would cause this - we already catch the autoChild case, 
            // so this is really a sanity check only
            this.logWarn("unexpected error - failed to find relationship between parent:"+
                        this.getID() + " and child:"+ canvas.getID());
            // return the standard root ID for the canvas - when parsing the strings back
            // we will have to explicitly catch this case?
            return canvas.getLocatorRoot();
        }
    },
    
    //> @method canvas.getInteriorLocator()
    // Get a relative Locator for an element contained within this Canvas
    // @param (DOMElement) DOM element contained within this Canvas
    // @return (Locator) abstract Locator String
    //<
    // Overridden to provide standard "meaningful locations" for ListGrids, DynamicForm, etc
    getInteriorLocator : function (element) {
        if (element && this.useEventParts) {
            var partObj = this.getElementPart(element);
            if (partObj != null && partObj.part != null) {
                // This will be of the format "partType_partID"
                return (partObj.partID && partObj.partID != isc.emptyString) ? 
                                        partObj.part + "_" +  partObj.partID : partObj.part;
            }
        }
        return isc.emptyString;
    },
    
    
    // -------------------------
    // Retrieving dom elements from locator strings
    //> @method canvas.getElementFromSplitLocator()
    // Given a locator string split into an array, return a pointer to the appropriate DOM element.
    // @param (DOMElement) DOM element contained within this Canvas
    // @return (Locator Array) array of strings
    // @visibility internal
    //<
    // Internal - the parameter format does not match the Locator format returned by
    // canvas.getLocator -- developers should call AutoTest.getElement() rather than directly 
    // accessing this method
    getElementFromSplitLocator : function (locatorArray) {
        var child = this.getChildFromLocatorSubstring(locatorArray[0]);
        if (child) {
            locatorArray.removeAt(0);
            return child.getElementFromSplitLocator(locatorArray);
        }
        // split finding the element within our handle to a separate method for simpler override
        return this.getInnerElementFromSplitLocator(locatorArray);
    },
    
    getChildFromLocatorSubstring : function (substring) {
        
        if (substring == null || substring == "") return null;
        
        // Standard formats:
        // 
        // Attribute pointing directly to widget:
        // EG:
        // - vscrollbar/hscrollbar 
        // - named autoChild
        if (isc.isA.Canvas(this[substring])) {
            return this[substring]
        }
        
        
        
        // Fallback locators ([childType][fallback locator for specific child])
        // EG:
        // - autoChildName[<fallback locator within auto children>]
        // - children[<fallback locator>]
        // - members[<fallback locator>]
        var fallbackLocatorConfig =  isc.AutoTest.parseLocatorFallbackPath(substring);
        if (fallbackLocatorConfig != null) {
            return this.getChildFromFallbackLocator(substring, fallbackLocatorConfig);
        }
        
                
        // if we're here, we didn't find any candidates, or didn't find a child within them.
        // No need to warn here -- this is likely to happen if the remaining identifier is
        // an inner element locator
        return null;
        
    },
    
    //> @type LocatorStrategy
    // The AutoTest subsystem relies on generating and parsing identifier strings to identify
    // components on the page. A very common pattern is identifying a specific component
    // within a list of possible candidates. There are many many cases where this pattern
    // is used, for example - members in a layout,tabs in a tabset, sections in a section stack.
    // <P>
    // In order to make these identifiers as robust as possible across minor
    // changes to an application, (such as skin changes, minor layout changes, etc) the
    // system will store multiple pieces of information about a component when generating
    // an identification string to retrieve it from a list of candidates.
    // The system has a default strategy for choosing the order in which to look at these
    // pieces of information but in some cases this can be overridden by setting
    // a <code>LocatorStrategy</code>.
    // <p>
    // By default we use the following strategies in order to identify a component from a list of
    // candidates:
    // <UL><li><code>name</code>: Does not apply in all cases but in cases where a specified
    //   <code>name</code> attribute has meaning we will use it - for example for
    //  +link{SectionStackSection.name,sections in a section stack}.</li>
    // <li><code>title</code>: If a title is specified for the component this may be used
    //   as a legitimate identifier if it is unique within the component - for example
    //   differently titled tabs within a tabset.</li>
    // <li><code>index</code>: Locating by index is typically less robust than by name or
    //   title as it is likely to be effected by layout changes on the page.</li>
    // </UL>
    // If an explicit strategy is specified, that will be used to locate the component if 
    // possible. If no matching component is found using that strategy, we will continue to
    // try the remaining strategies in order as described above. In other words setting
    // a locatorStrategy to "title" will skip attempting to find a component by name, and
    // instead attempt to find by title - or failing that by index.
    // <P>
    // Note that we also support matching by type (see +link{type:LocatorTypeStrategy}).
    // Matching by type is used if we were unable to match by name or title or to disambiguate
    // between multiple components with a matching title.
    //
    // @value "name" Match by name if possible.
    // @value "title" Match by title if possible.
    // @value "index" Match by index
    // @visibility autoTest
    //<
    
    //> @type LocatorTypeStrategy
    // When attempting to identify a component from within a list of possible candidates
    // as described +link{type:LocatorStrategy,here}, if we are unable to find a unique match
    // by name or title, we will use the recorded "type" of the component to verify
    // an apparent match.
    // <P>
    // By default we check the following properties in order:
    // <ul><li>Does the Class match?</li>
    //     <li>If this is not a +link{Class.isFrameworkClass,framework class}, does the
    //         core framework superclass match?</li>
    //     <li>Does the <code>role</code> match?</li>
    // </ul>
    // In some cases an explicit locatorTypeStrategy can be specified to modify this
    // behavior. As with +link{type:LocatorStrategy}, if we are unable to match using the
    // specified type strategy we continue to test against the remaining strategies in order - 
    // so if a type stratgy of "scClass" was specified but we were unable to find a match
    // with the appropriate core superclass, we will attempt to match by role.
    // Possible values are:
    // @value "Class" Match by class if possible
    // @value "scClass" Ignore specific class and match by the SmartClient framework superclass.
    // @value "role" Ignore class altogether and attempt to match by role
    // @value "none" Don't attempt to compare type in any way
    // @visibility autoTest
    //<

    //> @attr Canvas.locateChildrenBy (LocatorStrategy : null : IRWA)
    // Strategy to use when locating children in this canvas from an autoTest locator string.
    // 
    // @visibility autoTest
    //<
    
    //> @attr Canvas.locateChildrenType (LocatorTypeStrategy : null : IRWA)
    // +link{type:LocatorTypeStrategy} to use when finding children within this canvas.
    // @visibility autoTest
    //<
    
    //> @attr Canvas.locatePeersBy (LocatorStrategy : null : IRWA)
    // Strategy to use when locating peers of this canvas from an autoTest locator string.
    // 
    // @visibility autoTest
    //<
    
    //> @attr Canvas.locatePeersType (LocatorTypeStrategy : null : IRWA)
    // +link{type:LocatorTypeStrategy} to use when finding peers of this canvas.
    // @visibility autoTest
    //<
    
    // given a childType -- for example "peers"
    // figure out the specified child locator strategy.
    // Works by looking for this.locate[pluralName]By -- EG
    // locatePeersBy
    getChildLocatorStrategy : function (childType) {
        if (isc.AutoTest.locStrategyNames == null) {
            isc.AutoTest.locStrategyNames = {};
        }
        
        var attrName = isc.AutoTest.locStrategyNames[childType];
        if (attrName == null) {
            var pluralName = childType;
            if (this._locatorChildren[childType]) pluralName = this._locatorChildren[childType];
            attrName = isc.AutoTest.locStrategyNames[childType] =
                        "locate" + 
                        pluralName.substring(0,1).toUpperCase() + pluralName.substring(1) +
                        "By";
        }
        
        return this[attrName];
    },
    // Same type of logic for type-identifiers
    // checks for this.locate[pluralName]Type -- EG: locatePeersType
    getChildLocatorTypeStrategy : function (childType) {
           
        if (isc.AutoTest.locStrategyTypes == null) {
            isc.AutoTest.locStrategyTypes = {};
        }
        
        var attrName = isc.AutoTest.locStrategyTypes[childType];
        if (attrName == null) {
            var pluralName = childType;
            if (this._locatorChildren[childType]) pluralName = this._locatorChildren[childType];
            attrName = isc.AutoTest.locStrategyTypes[childType] =
                        "locate" + 
                        pluralName.substring(0,1).toUpperCase() + pluralName.substring(1) +
                        "Type";
        }
        
        return this[attrName];
    },
    
    
    // substring param really just used for logging
    getChildFromFallbackLocator : function (substring, fallbackLocatorConfig) {
    
        var type = fallbackLocatorConfig.name,
            config = fallbackLocatorConfig.config;
    
        // default logic:
        // we use the "name" to find candidate widgets, then use the config to
        // figure out which candidate we actually want
        var candidates = this.getFallbackLocatorCandidates(type);
        
        if (candidates && candidates.length > 0) {
            
           
            
            // Given an array of possible candidates attempt to match as follows:
            
            // - if a 'name' was recorded,
            //  - match by name and class name
            //  - otherwise by name and scClassName
            //  - otherwise by name and scRole
            // - if a title was recorded
            //  - match by title  and class name
            //  - title / scClassName
            //  - title / role
            //
            // Otherwise back off to matching by index:
            //  - try to match by class name / index (of candidates with that className)
            //  - then by scClassName / index
            //  - then by role / index
            //  - then by raw index
            
            // Robustness:
            // We have a big one-time warning to log when we think what we're returning is
            // likely unreliable (see AutoTest.logRobustLocatorWarning())
            // We do this:
            //  - if we find a match by name but it doesn't match class, scclass or role
            //  - if we find a match by title but it doesn't match class scclass or role
            //      (If there is more than one match by title we ignore this strategy and back
            //       off to index with a different warning)
            //  - if, when attempting to find a match by index (by class scClass or role, or by
            //    raw index), we find the array length has changed (meaning the array has
            //    changed, so the index is probably worthless).
            //
            // We also log a less "things are broken" warning everytime we return
            // by raw index as this is very fragile.
            var name = config.name;
            
            // Some common things we're always going to try:
            var className = config.Class,
                // scClass will not have been recorded separately if the recorded class
                // is already a core class.
                scClassName = config.scClass || config.Class,
                role = config.scRole;
                
            var strategy = this.getChildLocatorStrategy(type);
            if (strategy == null) strategy = "name";
            
            var typeStrategy = this.getChildLocatorTypeStrategy(type);
            if (typeStrategy == null) typeStrategy = "Class";
            
            
            switch (strategy) {
                
            case "name":
                                
                if (name != null) {
                    var nameMatch = candidates.find("name", name);
                    // we could check uniqueness as we do with title, but this seems very unlikely
                    // to be necessary - name is only really used as a unique ID within some
                    // array (though not globally unique)
                    
                    if (nameMatch) {
                        
                        switch (typeStrategy) {
                            
                        case "Class": // scClass // role // none
                        
                          
                            if (className && isc.isA[className] && isc.isA[className](nameMatch)) {
                                if (this.logIsDebugEnabled("AutoTest")) {
                                    this.logDebug("Locator string:" + substring + 
                                        " - returning widget with matching name and ClassName:" +
                                        nameMatch, "AutoTest");
                                }
                                return nameMatch;
                            }
                            
                        case "scClass":
                            
                            if (scClassName && isc.isA[scClassName] && isc.isA[scClassName](nameMatch)) 
                            {
                                if (this.logIsDebugEnabled("AutoTest")) {
                                    this.logDebug("Locator string:" + substring + 
                                        " - returning widget with matching name and scClassName:" +
                                        nameMatch, "AutoTest");
                                }
                                return nameMatch;
                            }
                            
                        case "role":
                        
                            // If the classes don't match - see if the roles match
                            var scRole = config.scRole;
                            if (nameMatch.waiRole == scRole) {
                                if (this.logIsDebugEnabled("AutoTest")) {
                                    this.logDebug("Locator string:" + substring + 
                                        " - returning widget with matching name and role:" +
                                        nameMatch, "AutoTest");
                                }
                                return nameMatch;
                            }
                        
                        default:
                            
                            // In this case we've got a matching name but we can't match it to
                            // class or role. This is still the most likely candidate (better than
                            // backing off to checking index), so log a warning and return it:
                            
                            if (typeStrategy != "none") {
                                isc.AutoTest.logRobustLocatorWarning();
                                this.logWarn("Locator string:" + substring + 
                                    ". Returning closest match:" + nameMatch + ". This has the same name " +
                                    "as the recorded component but does not match class or role. ", "AutoTest");
                            } else {
                                 if (this.logIsDebugEnabled("AutoTest")) {
                                    this.logDebug("Locator string:" + substring + 
                                        " - returning widget with matching name:" +
                                        nameMatch, "AutoTest");
                                }
                            }
                                
                            return nameMatch;
                        }
                    }
                }
                
                
                
            case "title":
                var title = config.title;
                if (title != null) {
                    var titleMatches = candidates.findAll("title", title);
                    
                    if (titleMatches && titleMatches.length > 0) {
                        var titleMatch;
                        
                        
                        switch (typeStrategy) {
                            
                        case "Class": // scClass // role // none
                            if (className) {
                                var titleInnerMatches = titleMatches.findAll("Class", className);
                                if (titleInnerMatches != null) {
                                    titleMatch = titleInnerMatches[0];
                                    if (titleInnerMatches.length == 1 && titleMatch) {
                                        if (this.logIsDebugEnabled("AutoTest")) {
                                            this.logDebug("Locator string:" + substring + 
                                                " - returning widget with matching title and ClassName:" +
                                                titleMatch, "AutoTest");
                                        }
                                        return titleMatch;
                                    }
                                }
                            }
                            
                        case "scClass":
                            if (scClassName) {
                                var titleInnerMatches = titleMatches.findAll("_scClass", scClassName);
                                if (titleInnerMatches != null) {
                                    if (titleInnerMatches.length ==1 || titleMatch == null)
                                        titleMatch = titleInnerMatches[0];
                                   
                                    if (titleInnerMatches.length == 1 && titleMatch) {
                                            
                                        if (this.logIsDebugEnabled("AutoTest")) {
                                            this.logDebug("Locator string:" + substring + 
                                                " - returning widget with matching name and scClassName:" +
                                                titleMatch, "AutoTest");
                                        }
                                        return titleMatch;
                                    }
                                }
                            }
                        case "role":
                            if (role) {
                                var titleInnerMatches = titleMatches.findAll("waiRole", role);
                                if (titleInnerMatches != null) {
                                    if (titleInnerMatches.length ==1 || titleMatch == null)
                                        titleMatch = titleInnerMatches[0];
                                   
                                    if (titleInnerMatches.length == 1 && titleMatch) {
                                        
                                        if (this.logIsDebugEnabled("AutoTest")) {
                                            this.logDebug("Locator string:" + substring + 
                                                " - returning widget with matching title and role:" +
                                                titleMatch, "AutoTest");
                                        }
                                        return titleMatch;
                                    }
                                }
                            }
                            
                        default:
                            // In this case we've got a matching title but we can't match it to
                            // class or role.
                            // Log the "unreialble locator" one time warning -- the fact that
                            // we couldn't find a match by class as well as title implies things
                            // must have changed since the recording was made...
                            //
                            // Return the match if it's unique, otherwise ignore it and move on to 
                            // matching by index.
                            
                            if (titleMatches.length == 1) {
                                
                                if (typeStrategy != "none") {
                                    isc.AutoTest.logRobustLocatorWarning();
                                   
                                    this.logWarn ("Locator string:" + substring + 
                                        ". Returning closest match:" + titleMatches[0] + ". This has the same title " +
                                        "as the recorded component but does not match class or role.", "AutoTest");
                                } else {
                                    if (this.logIsDebugEnabled("AutoTest")) {
                                        this.logDebug("Locator string:" + substring + 
                                            " - returning widget with matching title:" +
                                            titleMatch, "AutoTest");
                                    }
                                }
                                return titleMatches[0];
                            } else {
                                this.logWarn("Locator string:" + substring +
                                    ", attempt to match by title failed -- multiple candidate components have this " +
                                    "same title. Attempting to match by index instead.", "AutoTest");
                            }
                        } // end of inner switch
                    }
                }
                
            // either strategy is "index" or we didn't find a title/name match
            default:
                    
                
                // back off to index
                // We captured index per class name, per scClass and per role as well as the
                // raw index in the array.
                // Test them in that order.
                // Note that if the lengths have changed this is likely wrong!
                 var classIndexMatch,
                    scClassIndexMatch,
                    roleIndexMatch;
                    
                 switch (typeStrategy) {
                 case "Class": // scClass // role // none
                  
        
                    if (className && config.classIndex) {
                        var classMatches = candidates.findAll("Class", className);
                        if (classMatches && classMatches.length > 0) {
                            
                            classIndexMatch = classMatches[parseInt(config.classIndex)];
                            
                            if (classMatches.length == parseInt(config.classLength)) {
                            
                                if (this.logIsInfoEnabled("AutoTest")) {
                                    this.logInfo("Locator string:" + substring + 
                                            " - returning widget with matching ClassName / index by ClassName:" +
                                            classIndexMatch, "AutoTest");
                                }
                                return classIndexMatch;
                            }
                            // If the lengths didn't match, the index is very likely unreliable
                            // Hang onto it to return it if we can't match by scClassName or role more
                            // reliably
                        }
                    }
                    
                case "scClass":
                    
                    if (scClassName && config.scClassIndex) {
                        
                        var scClassMatches = candidates.findAll("_scClass", scClassName);
                        if (scClassMatches && scClassMatches.length > 0) {
                            
                            scClassIndexMatch = scClassMatches[parseInt(config.scClassIndex)];
                            
                            if (sClassMatches.length == parseInt(config.scClassLength)) {
                            
                                if (this.logIsInfoEnabled("AutoTest")) {
                                    this.logInfo("Locator string:" + substring + 
                                            " - returning widget with matching SmartClient superclass / index by ClassName:" +
                                            scClassIndexMatch, "AutoTest");
                                }
                                return scClassIndexMatch;
                            }
                            // If the lengths didn't match, the index is very likely unreliable
                            // Try roles before using this
                        }
                    }
                    
                case "role":
                    
                    if (role && config.roleIndex) {
                        
                        var roleMatches = candidates.findAll("waiRole", role);
                        if (roleMatches && roleMatches.length > 0) {
                            
                            roleIndexMatch = roleMatches[parseInt(config.roleIndex)];
                            
                            if (roleMatches.length == parseInt(config.roleLength)) {
                            
                                if (this.logIsInfoEnabled("AutoTest")) {
                                    this.logInfo("Locator string:" + substring + 
                                            " - returning widget with matching role / index by role:" +
                                            roleIndexMatch, "AutoTest");
                                }
                                return roleIndexMatch;
                            }
                        }
                    }
                    
                default:
                    
                    // At this point if we had class/scClass or role, we know the lengths have changed
                    // so index is very unreliable.
                    // In this case, or if the overall length has changed, log the robustLocatorWarning
                    //
                    // Then return our best guess
                    if ((typeStrategy != "none" && (className || scClassName || role)) || 
                        (config.length != null && (parseInt(config.length) != candidates.length))) 
                    {
                        isc.AutoTest.logRobustLocatorWarning();
                    }
                    
                    var match = classIndexMatch || scClassIndexMatch || roleIndexMatch;
                    if (match == null) {
                        var index = config[isc.AutoTest.fallback_valueOnlyField];
                        if (index == null) index = config.index;
                        index = parseInt(index);
                        
                        match = candidates[index];
                    }
                    
                    if (match) {
                        this.logWarn("Locator string:" + substring + 
                            " matching by index gave " + match +
                            ". Reliability cannot be guaranteed for matching by index if the underlying " +
                            "application undergoes any changes.", "AutoTest");
                        return match;
                    }
                } // closes inner switch statement
            } // closes outer switch statement
        } // closes if (candidates.length > 0)
        
        // if we're here, we didn't find any candidates, or didn't find a child within them.
        // This doesn't necessarily indicate any kind of failure: We use fallback locators
        // for elements within some components - EG list grid cells
        this.logDebug("AutoTest.getElement(): locator substring:" + substring + 
            " parsed to fallback locator name:" + name + 
            ", unable to find relevant child - may refer to inner element.", "AutoTest");
    },
    
    
    _locatorChildren:{
        peer:"peers",
        child:"children"
    },
    getFallbackLocatorCandidates : function (name) {
    
        var candidates;
        
        // check _createdAutoChildren for autoChildren by autoChild name
        if (this._createdAutoChildren != null && this._createdAutoChildren[name] != null) {
            var IDs = this._createdAutoChildren[name];
            candidates = [];
            for (var i = 0; i < IDs.length; i++) {
                candidates[i] = window[IDs[i]];
            }
            
        // _locatorChildren object: This specifies a mapping between known cases where
        // we have an attribute on this widget containing an array of candidates
        // (EG the children array) and a known 'locator' childType name (EG "child")
        
        } else if (this._locatorChildren[name] != null) {
            candidates = this[this._locatorChildren[name]];
        
        // Also support the 'name' pointing directly to an attribute on this widget 
        // containing an array of candidate objects (So could store "children" directly
        // rather than using the remapping above).
        } else if (this[name] && isc.isAn.Array(this[name])) {
            candidates = this[name];
        }
        return candidates;
    },
    
    
    emptyLocatorArray : function (locatorArray) {
        return locatorArray == null || locatorArray.length == 0 ||
                (locatorArray.length == 1 && locatorArray[0] == "");
    },
    
    getInnerElementFromSplitLocator : function (locatorArray) {
        
        if (!this.emptyLocatorArray(locatorArray)) {
            // support event-parts in all canvii
            if (locatorArray.length == 1) {
                
                var parts = locatorArray[0].split("_");
                
                var part = {
                        part:parts[0],
                        partID:parts[1]
                    };
                var element = this.getPartElement(part);
                if (element) return element;
            }
            
        }
        return this.getHandle();
    }
    
    

});
          
// -----------------------------------------------------------------
// Override getChildLocator() for special cases

if (isc.Layout) {
    isc.Layout.addProperties({
            
        //> @attr Layout.locateMembersBy (LocatorStrategy : null : IRWA)
        // Strategy to use when locating members from within this Layout's members array.
        // 
        // @visibility autoTest
        //<
        
        //> @attr Layout.locateMembersType (LocatorTypeStrategy : null : IRWA)
        // +link{type:LocatorTypeStrategy} to use when finding members within this layout.
        // @visibility autoTest
        //<
        
            
        getStandardChildLocator : function (canvas) {
            var nlcs = this.getNamedLocatorChildString(canvas);
            if (nlcs) return nlcs;
            
            if (this.members.contains(canvas)) {
                return this.getCanvasLocatorFallbackPath("member", canvas, this.members);
            }
            
            return this.Super("getStandardChildLocator", arguments);
        },
        
        
        _locatorChildren:{
            member:"members",
            peer:"peers",
            child:"children"
        }
    });
}

if (isc.Window) {
    isc.Window.addProperties({
        // Code in Window.js sets up Windows as the 'locatorParent' of their items
        containsLocatorChild : function (canvas) {
            if (this.items && this.items.contains(canvas)) return true;
            return this.Super("containsLocatorChild", arguments);
        },
        getStandardChildLocator : function (canvas) {
        
            if (this.items && this.items.contains(canvas)) {
                var template = this._childLocatorTemplate;
                template[0] = "item";
                template[2] = this.items.indexOf(canvas);
                template[4] = canvas.getClassName();
                
                return template.join(isc.emptyString);
            }
            
            return this.invokeSuper(isc.Window, "getStandardChildLocator", canvas);            
        },
        
        _locatorChildren:{
            item:"items",
            member:"members",
            peer:"peers",
            child:"children"
        }
    });
}
//  - in a Window, for an non-autoChild item, item[itemIndex][Class="className"]

if (isc.SectionStack) {
    
    // add the _locatorChildren for SectionHeader / ImgSectionHeader - this will
    // allow them to parse the item[fallbacklocator] generated by the
    // sectionStack standard child locator override below
    isc.ImgSectionHeader.changeDefaults("_locatorChildren", {item:"items"});
    isc.SectionHeader.changeDefaults("_locatorChildren", {item:"items"});

    
    // add sections to locatorChildren for SectionStack - allows it to parse the
    // section[fallbackLocator] we create below
    isc.SectionStack.changeDefaults("_locatorChildren", {section:"sections"});
    
    isc.SectionStack.addProperties({
            
        // override getStandardChildLocator - for sections return 
        //  section[name="name"||title="title"||3]
        // for items, append
        //  item[0]
        getStandardChildLocator : function (canvas) {
            var sections = this.sections || [],
                locatorString;
            for (var i = 0; i < sections.length; i++) {
    
                var items = sections[i].items,
                    section, item;
                if (canvas == sections[i]) {
                    section = canvas;
                    
                } else if (items && items.contains(canvas)) {
                    
                    section = sections[i];
                    item = canvas;
                }
                
                if (section != null) {
                    
                    // This will pick up name by default, then title, index, etc
                    locatorString = this.getCanvasLocatorFallbackPath("section", section, this.sections);
                }
                
                if (item != null) {
                    locatorString += "/" + this.getCanvasLocatorFallbackPath("item", item, section.items);
                }
                if (locatorString != null) return locatorString;
            }
            
            return this.Super("getStandardChildLocator", arguments);
        }
           
        //> @attr SectionStack.locateSectionsBy (LocatorStrategy : null : IRWA)
        // When +link{isc.AutoTest.getElement()} is used to parse locator strings generated by
        // link{isc.AutoTest.getLocator()}, how should sections within this stack be identified?
        // By default if section has a specified +link{Section.name} this will always be used.
        // For sections with no name, the following options are available:
        // <ul>
        // <li><code>"title"</code> use the title as an identifier</li>
        // <li><code>"index"</code> use the index of the section in the sections array as an identifier</li>
        // </ul>
        // 
        // If unset, and the section has no specified name, default behavior is to
        // identify by title (if available), otherwise by index.
        // @visibility autoTest
        //<
        
        //> @attr SectionStack.locateSectionsType (LocatorTypeStrategy : null : IRWA)
        // +link{type:LocatorTypeStrategy} to use when finding Sections within this section Stack.
        // @visibility autoTest
        //<
        

        // This will be picked up automatically based on the _locatorChildren object and
        // the standard "getLocatorStrategy()" logic
        
            
    });  
}

// --------------------------------------------------
// Interior locators

if (isc.StretchImg) {
isc.StretchImg.addProperties({
    getInteriorLocator : function (element) {
        // We don't use the useEventParts flag in StretchImgs but in some cases we need to tell the
        // difference between events on different items
        // (EG a track-click and a button click)
        var origElement = element,
            handle = this.getHandle(), canvasName = this.getCanvasName();

        while (element && element != handle && element.getAttribute) {
            // check the "name" property for the open-icon 
            var ID = element.getAttribute("name");
            if (ID && ID.startsWith(canvasName)) {
                return ID.substring(canvasName.length);
            }
            element = element.parentNode;
        }
        return this.Super("getInteriorLocator", [origElement]);
    },
    
    getInnerElementFromSplitLocator : function (locatorArray) {
        
        // check for "name" - used for parts
        if (!this.emptyLocatorArray(locatorArray) && locatorArray.length == 1) {
            var image = this.getImage(locatorArray[0]);
            if (image) return image;
        }
        return this.Super("getInnerElementFromSplitLocator", arguments);
    }
    
    
    
});
}


// label.icon already handled via standard canvas 'eventPart' handling

if (isc.DynamicForm) {
    isc.DynamicForm.addProperties({
        getInteriorLocator : function (element) {
            var itemInfo = isc.DynamicForm._getItemInfoFromElement(element, this);
            // itemInfo format:
            // {item:item, overElement:boolean, overTitle:boolean, overTextBox:boolean,
            //  overControlTable:boolean, overIcon:string}
            if (!itemInfo.item) return this.Super("getInteriorLocator", arguments);
            var item = itemInfo.item,
                locator = [this.getItemLocator(item), '/'];
                
            if (itemInfo.overElement) locator[locator.length] = "element";
            else if (itemInfo.overTitle) locator[locator.length] = "title";
            else if (itemInfo.overTextBox) locator[locator.length] = "textbox";
            else if (itemInfo.overControlTable) locator[locator.length] = "controltable";
            else if (itemInfo.overIcon) locator[locator.length] = "[icon='" + itemInfo.overIcon + "']"
            
            return locator.join(isc.emptyString);
        },
        
        getItemLocator : function (item) {
            var itemIdentifiers = {};
            
            if (item.name != null) itemIdentifiers.name = item.name;
            
            // Title - default strategy if no name
            var title = item.getTitle();
            if (title != null) itemIdentifiers.title = title;
            
            // Value - useful for things like header items where value is pretty much
            // a valid identifier
            var value = item.getValue();
            if (value != null) itemIdentifiers.value = value;
            
            // Index - cruder identifier
            itemIdentifiers.index = this.getItems().indexOf(item);
            
            // ClassName: Not used by default
            itemIdentifiers.Class = item.getClassName();
            
            var IDString = isc.AutoTest.createLocatorFallbackPath("item", itemIdentifiers);
            return IDString;
        },
        
        containsLocatorChild : function (canvas) {
            if (isc.isA.DateChooser(canvas) && canvas.callingForm == this) return true;
            return this.Super("containsLocatorChild", arguments);
        },
        getChildLocator : function (canvas) {
            if (canvas.canvasItem) {
                var item = canvas.canvasItem;
                return this.getItemLocator(item) + "/canvas";
            }
            if (isc.isA.PickListMenu(canvas)) {
                var item = canvas.formItem;
                return this.getItemLocator(item) + "/pickList";
            }
            if (isc.isA.DateChooser(canvas)) {
                var item = canvas.callingFormItem;
                return this.getItemLocator(item) + "/picker";
            }
            return this.Super("getChildLocator", arguments);
        },
        
        getItemFromSplitLocator : function (locatorArray) {
            
            var fullItemID = locatorArray[0],
                className;

            // BackCompat note: Old format for identifying form items was
            //   item[name="foo"][Class="TextItem"]
            // new format is
            //   item[name=foo||title=moo||index=2||Class=TextItem]
            // Handle the old format for backCompat
            if (fullItemID.contains("[Class=")) {
                var split = fullItemID.match(
                    "item\\[(.+)'\\]\\[Class=\"(.+)\"\\]"
                );
                className = split[1].substring(6, split[1].length-2);
                fullItemID = split[0];
            }
            
            var itemConfig = isc.AutoTest.parseLocatorFallbackPath(fullItemID);
            
            if (itemConfig.name == "item" && itemConfig.config != null) {
                var config = itemConfig.config;
                
                //this.logWarn('config: ' + this.echo(config));
                
                // if we have a valid name, always have it take precedence
                var item;
                if (config.name != null) {
                    item = this.getItem(config.name);
                } else {
                    //this.logWarn("item locator:" +fullItemID + " has no name - checking for " +
                    //    " title etc.");
                    
                    // no name - check for the item 'locateItemBy' setting
                    // Options are by title or by value
                    for (var i = 0; i < this.items.length; i++) {
                        var testItem = this.items[i],
                            locateItemBy = testItem.locateItemBy;
                        if (locateItemBy == null) locateItemBy = "title";
                        //this.logWarn("item:" + testItem + ", locate by:" + locateItemBy + 
                        //    "config[locateBy:" + config[locateItemBy]);
                        if (locateItemBy == "title" && config.title != null && 
                            testItem.title == config.title) 
                        {
                            item = testItem;
                        } else if (locateItemBy == "value" && config.value != null && 
                                    testItem.getValue() == config.value) 
                        {
                            item = testItem;
                        }
                    }
                    
                    // If we couldn't find the item by title or value (or locateItemBy was
                    // specified explicitly as index) - locate by index
                    if (item == null) {
                        var index = config.index;
                        if (isc.isA.String(index)) {
                            if (index.startsWith("'") ||
                                index.startsWith('"')) 
                            {
                                index = index.substring(1);
                            }
                            index = parseInt(index);
                        }
                        item = this.items[index];
                    }
                }
              
                if (!item) {
                    this.logWarn("AutoTest.getElement(): Unable to find item from " +
                        "locator string:" + fullItemID);
                    return null;
                }
                
                if (!isc.isA[className] || !isc.isA[className](item)) {
                    this.logWarn("AutoTest.getElement(): identifier:"+ fullItemID + 
                                " returned an item of class:"+ item.getClassName());
                }
                return item;
            }
            
            return null;
        },
        
        getInnerElementFromSplitLocator : function (locatorArray) {
            if (this.emptyLocatorArray(locatorArray)) {
                return this.getHandle();
            }
            var item = this.getItemFromSplitLocator(locatorArray);
            if (item != null) {
                locatorArray.removeAt(0);
                return item.getInnerElementFromSplitLocator(locatorArray);
            }
            return this.getHandle();
        }
    });
    
    isc.FormItem.addProperties({
        
        //> @attr FormItem.locateItemBy (string : null : IRWA)
        // When +link{isc.AutoTest.getElement()} is used to parse locator strings generated by
        // link{isc.AutoTest.getLocator()} for this form item, should the item be identified?
        // By default if the item has a name this will always be used, however for items with
        // no name, the following options are available:
        // <ul>
        // <li><code>"title"</code> use the title as an identifier within this form</li>
        // <li><code>"value"</code> use the value of the item to identify it (often used
        //  for items with a static defaultValue such as HeaderItems</li>
        // <li><code>"index"</code> use the index within the form's items array.
        // </ul>
        // 
        // If unset, and the item has no specified name, default behavior is to
        // identify by title (if available), otherwise by index.
        // @visibility autoTest
        //<
        getInnerElementFromSplitLocator : function (locatorArray) {
            if (!this.emptyLocatorArray(locatorArray)) {
                var part = locatorArray[0];
                if (part == "element") return this.getDataElement();
                if (part == "title") return this.form.getTitleCell(this);
                if (part == "textbox") return this._getTextBoxElement();
                if (part == "controltable") return this._getControlTabelElement();
                
                // canvasItems
                if (part == "canvas") {
                    if (this.canvas) {
                        locatorArray.removeAt(0);
                        return this.canvas.getElementFromSplitLocator(locatorArray);
                    }
                }
                
                // picker (EG date picker)
                if (part == "picker") {
                    if (this.picker) {
                        locatorArray.removeAt(0);
                        return this.picker.getElementFromSplitLocator(locatorArray);
                    }
                }
                
                // pickList
                if (part == "pickList") {
                    if (!this.pickList) this.makePickList(false);
                    locatorArray.removeAt(0);
                    return this.pickList.getElementFromSplitLocator(locatorArray);
                }
                
                // If passed an icon, return a pointer to the img element 
                // Event if there is a link element, it'll be above that in the DOM
                var iconSplit = part.match("\\[icon='(.+)'\\]"),
                    iconID = part ? part[1] : null;
                if (iconID) {
                    return this._getIconImgElement(iconID);
                }
            }
        },
        
        // copy the 'emptyLocatorArray()' helper function across
        emptyLocatorArray:isc.Canvas.getPrototype().emptyLocatorArray
    });
    
    
    isc.HeaderItem.addProperties({
        //> @attr HeaderItem.locateItemBy (string : "value" : IRWA)
        // Default to locating header items by value
        // @visibility autoTest
        //<
        locateItemBy:"value"
    });
    
    
    if (isc.PickListMenu) {
        isc.PickListMenu.addProperties({
            getLocatorParent : function () {
                if (this.formItem) return this.formItem.form;
                return this.Super("getLocatorParent", arguments);
            }
        });
    }
}


if (isc.GridRenderer) {
    
    isc.GridRenderer.addProperties({
        getInteriorLocator : function (element) {
            var origElement = element,
                handle = this.getHandle(),
                table = this.getTableElement();
            // assertion if we haven't rendered out our tableElement, assume we
            if (!table) return isc.emptyString;
            var rows = table.rows,
                tagName,
                row, cell,
                tr = "tr", TR = "TR",
                td = "td", TD = "TD";
            while (element && element != table && element != handle) {
                
                tagName = element.tagName;           
                // document whether it's upper / lower case by default
                if (tagName == td || tagName == TD) {
                    cell = element;
                }
                
                // document whether it's upper / lower case by default
                if (tagName == tr || tagName == TR) {
                    row = element;
                }
                // keep going in case there are nested tables, etc
                element = element.parentNode;
            }
            if (!row || !cell) return this.Super("getInteriorLocator", [origElement]);
            
            var rows = table.rows, rowNum, logicalRowNum;
            for (var i = 0; i < rows.length; i++) {
                if (rows[i] == row) {
                    rowNum = i;
                    break;
                }
            }
            var cells = row.cells, colNum, logicalColNum;
            for (var i = 0; i < cells.length; i++) {
                if (cells[i] == cell) {
                    colNum = i;
                    break;
                }
            }
            logicalRowNum = rowNum + (this._firstDrawnRow || 0);
            logicalColNum = colNum + (this._firstDrawnCol || 0);
            
            return this.getCellLocator(logicalRowNum, logicalColNum);
            
        },
        
        getCellLocator : function (rowNum, colNum) {
            return "row[" + rowNum + "]/col[" + colNum + "]"
        },
        
        getInnerElementFromSplitLocator : function (locatorArray) {
            
            if (this.emptyLocatorArray(locatorArray)) return this.getHandle();
            
            // Format should be [row[index], col[index]]
            if (locatorArray.length == 2) {
                var cell = this.getCellFromLocator(locatorArray[0], locatorArray[1]),
                    rowNum = cell[0], colNum = cell[1];
                
                if (isc.isA.Number(rowNum) && isc.isA.Number(colNum)) {
                    // We suppress all events on row/cols during row animation
                    // in this case suppress the element entirely so auto-test engines
                    // don't attempt to fire events on them.
                    
                    if (this._suppressEventHandling()) return null;
            
                    return this.getTableElement(rowNum, colNum);
                }
            }
            return this.Super("getInnerElementFromSplitLocator", arguments);
        },
        
        // assumes rowLocator is row[rowNum]
        // colLocator is col[colNum]
        getCellFromLocator : function (rowLocator, colLocator) {
            // This is a straight parse - to support being passed a fuller format and
            // just extracting the index, if present, we'd want to have 
            // AutoTest.parseFallbackLocator run and then extract the standalone field value
            // knowing that's an index.
            var rowString = rowLocator.substring(4, rowLocator.length-1),
                colString = colLocator.substring(4, colLocator.length-1);
            return [rowNum,colNum];
        }
    })

}
if (isc.ListGrid) {
      isc.ListGrid.addProperties({
          // we explicitly set up the locatorParent pointers on these widgets
          // in ListGrid.js
          namedLocatorChildren:[
              "header", "frozenHeader", "body", "frozenBody", "_editRowForm"
          ]
      });
      
      isc.GridBody.addProperties({
              getCellLocator : function (rowNum, colNum) {
                  var grid = this.grid;
                  if (grid == null) return this.Super("getCellLocator", arguments);
                  
                  
                  var locatorOptions = {},
                    gridColNum = grid.getFieldNumFromLocal(colNum, this),
                    record = grid.getCellRecord(rowNum, gridColNum),
                    ds = grid.getDataSource();
                    
                  if (ds != null) {
                      var pk = ds.getPrimaryKeyFieldName();
                      if (pk != null && record[pk] != null) {
                          locatorOptions[pk] = record[pk];
                      }
                  }
                  
                  var titleField = grid.getTitleField();
                  if (titleField != null && record[titleField] != null) {
                      locatorOptions[titleField] = record[titleField];
                  }
                  var fieldName = grid.getFieldName(gridColNum);
                  if (record[fieldName] != null) {
                      locatorOptions[fieldName] = record[fieldName];
                  }
                  
                  // also store the rowNum
                  locatorOptions[isc.AutoTest.fallback_valueOnlyField] = rowNum;
                  
                  var rowString = isc.AutoTest.createLocatorFallbackPath("row", locatorOptions);
                  
                  locatorOptions = {};
                  var fieldName = grid.getFieldName(gridColNum);
                  if (fieldName != null) locatorOptions.fieldName = fieldName;
                  locatorOptions[isc.AutoTest.fallback_valueOnlyField] = colNum;
                  
                  var colString = isc.AutoTest.createLocatorFallbackPath("col", locatorOptions);
                  return rowString + "/" + colString;
                  
              },
              
                           
                getCellFromLocator : function (rowLocator, colLocator) {
                    var grid = this.grid;
                    if (grid == null) return this.Super("getCellFromLocator", arguments);
                    
                    var rowConfig = isc.AutoTest.parseLocatorFallbackPath(rowLocator),
                        colConfig = isc.AutoTest.parseLocatorFallbackPath(colLocator),
                        rowNum = this.getRowNumFromLocatorConfig(rowConfig.config),
                        colNum = this.getColNumFromLocatorConfig(colConfig.config);
                    return [rowNum,colNum];
                },
                
                getRowNumFromLocatorConfig : function (rowConfig) {
                    //this.logWarn("rowConfig:" + this.echo(rowConfig));
                    var grid = this.grid,
                        locateRowsBy = grid.locateRowsBy;
               
                    if (locateRowsBy == null) locateRowsBy = "primaryKey";
                    switch(locateRowsBy) {
                        case "primaryKey":
                            //this.logWarn("trying to locate by pk");
                            var ds = grid.getDataSource();
                            if (ds != null) {
                                var pkField = ds.getPrimaryKeyFieldName();
                                if (ds != null && rowConfig[pkField] != null) {
                                    return grid.findRowNum(rowConfig);
                                }
                            }
                            // don't break - if we were unable to use PK, fall back through
                            // titleField / cell value before index
                                
                        case "titleField":
                            //this.logWarn("trying to locate by title field");
                            var titleField = grid.getTitleField();
                            if (titleField != null && rowConfig[titleField] != null) {
                                var data = grid.data;
                                return data.findIndex(titleField, rowConfig[titleField]);
                            }
                            
                        case "targetCellValue":
                            //this.logWarn("trying to locate by target");
                            // Assertion: In this case, there was no titleField or primary key
                            // on the config object.
                            // This relies on the fact that we wouldn't store "null"s on that object
                            // when creating the locator options.
                            // All that's left is the original index under the fallback_valueOnlyField
                            // array and the target row cell value
                            for (var fieldName in rowConfig) {
                                if (fieldName == isc.AutoTest.fallback_valueOnlyField) continue;
                                
                                if (rowConfig[fieldName] != null) {
                                    return grid.data.findIndex(fieldName, rowConfig[fieldName]);
                                }
                            }
                        default:
                            //this.logWarn("locate by rowNum");
                            // Final fallback option- original rowNum as stored
                            // Technically this is locateRowsBy "index"
                            return parseInt(rowConfig[isc.AutoTest.fallback_valueOnlyField]);
                    }
                    
                },
                
                getColNumFromLocatorConfig : function (colConfig) {
                    
                    //this.logWarn("colConfig:" + this.echo(colConfig));
                    var grid = this.grid;
                    var locateColsBy = grid.locateColumnsBy;
                    //locateColsBy will be one of ("fieldName", "index")    
                    
                    if (locateColsBy == "fieldName" || locateColsBy == null) {
                        var fieldName = colConfig.fieldName;
                        if (fieldName != null) {
                            return grid.getFieldNum(fieldName);
                        }
                    }
                    
                    // If no fieldName stored, use the previous colNum instead
                    return parseInt(colConfig[isc.AutoTest.fallback_valueOnlyField]);
                    
                }
      });
}
if (isc.TreeGrid) {
    isc.TreeGridBody.addProperties({
        getInteriorLocator : function (element) {
            var origElement = element;
            
            var handle = this.getHandle(),
                tableElement = this.getTableElement();
                
            if (!element || !handle || !tableElement) return isc.emptyString;
            var openAreaPrefix = this.grid.getCanvasName() + this.grid._openIconIDPrefix,
                rowNum, colNum;
   
            // optimization - we could duplicate the logic from GR here and avoid double-iterating
            // through the DOM if we're NOT in the open area of the TG.
            while (element != this.tableElement && element != handle && element.getAttribute) {
                // check the "name" property for the open-icon 
                var ID = element.getAttribute("name");
                if (ID && ID.startsWith(openAreaPrefix)) {
                    rowNum =  ID.substring(openAreaPrefix.length);
                    colNum = this.grid.getTreeFieldNum();
                    return "row" + rowNum + "/col" + colNum + "/open";
                }
                element = element.parentNode;
            }
            
            return this.Super("getInteriorLocator", [origElement]);
        },
        
        
          
        getInnerElementFromSplitLocator : function (locatorArray) {
            
            if (this.emptyLocatorArray(locatorArray)) return this.getHandle();
            
            // Additional Format is: [row[index], col[index], open]
            if (locatorArray.length == 3 && locatorArray[2] == "open") {
                // We suppress all events on row/cols during row animation
                // Also suppress toggleFolder event target in this case.
                
                if (this._suppressEventHandling()) return null;
                            
                var rowNum = parseInt(locatorArray[0].substring(3)),
                    colNum = parseInt(locatorArray[1].substring(3));

                // use getImage since we write a name into the opener icon.
                var openerID = this.grid._openIconIDPrefix + rowNum,
                    image = this.grid.getImage(openerID);
                if (image) return image;
                
            }
            return this.Super("getInnerElementFromSplitLocator", arguments);
        }
    })
}


// TabSets:
// We want to be able to locate tabs by ID or title rather than just index so if the order
// changes they continue to be accessable
if (isc.TabSet) {
    isc.TabSet.addProperties({
        
        // Relevant logic outside this file:
        //
        // In TabSet: tabBarControls layout has locatorParent / namedLocatorChildren set such that
        // the tabset will point directly to that auto-child by name.
        
        
        // In TabBar we have logic in makeButton to set 'locatorParent' on tabs to point
        // straight to the TabSet
        
        // Need to update containsLocatorChild / getStandardChildLocator / ... ? _locatorChildren??
        containsLocatorChild : function (canvas) {
            if (this.Super("containsLocatorChild", arguments)) return true;
            
            if (this.getTabNumber(canvas) != -1) return true;
            return false;
        },
        
        getStandardChildLocator : function (canvas) {
            var tabNum = this.getTabNumber(canvas);
            if (tabNum != -1) {
                var tabObj = this.getTabObject(tabNum);
                
                var locatorConfig = {};
                // locate by ID, title or index
                if (tabObj.ID != null) locatorConfig.ID = tabObj.ID;
                if (tabObj.title != null) locatorConfig.title = tabObj.title;
                locatorConfig.index = tabNum;
                
                return isc.AutoTest.createLocatorFallbackPath("tab", locatorConfig);
            
            }
            return this.Super("getStandardChildLocator", arguments);
        },
        
        //> @attr TabSet.locateTabsBy (string : null : IRWA)
        // When +link{isc.AutoTest.getElement()} is used to parse locator strings generated by
        // link{isc.AutoTest.getLocator()}, how should tabs within this tabset be identified?
        // By default if tab has a specified +link{Tab.ID} this will always be used.
        // For tabs with no ID, the following options are available:
        // <ul>
        // <li><code>"title"</code> use the title as an identifier</li>
        // <li><code>"index"</code> use the index of the tab in the tabset as an identifier</li>
        // </ul>
        // 
        // If unset, and the tab has no specified ID, default behavior is to
        // identify by title (if available), otherwise by index.
        // @visibility autoTest
        //<
        getChildFromLocatorSubstring : function (substring) {
            
            // this startsWith("tab[") is a bit of a hack we will probably just pass the
            // substring to AutoTest.parseLocatorFallbackPath directly and look at the returned
            // 'name' property -- however not sure if it'll handle all formats right now.
            if (substring && substring.startsWith("tab[")) {
                var fallbackConfig = isc.AutoTest.parseLocatorFallbackPath(substring),
                    config = fallbackConfig.config;
                
                // If ID is present, always respect it:
                
                if (config.ID != null) {
                    return this.getTab(config.ID);
                }
                var locateTabsBy = this.locateTabsBy;
                if (locateTabsBy == null) locateTabsBy = "title";
                
                if (config.title && locateTabsBy == "title") {
                    var tabNum = this.tabs.findIndex("title", config.title);
                    return this.getTab(tabNum);
                }
                // last case -- we want to use the raw tab index.
                return this.getTab(parseInt(config.index));
            }
            
            return this.Super("getChildFromLocatorSubstring", substring);
        }
        
    });
}

// ----------------------------------------------
// Returning element from interior locator

if (isc.StatefulCanvas) {
    isc.StatefulCanvas.addProperties({
          
        getInnerElementFromSplitLocator : function (locatorArray) {
            // label floats over statefulCanvas - if we have a specified part, assume it occurred
            // in the label since that's where we write out our icon, etc.
            if (!this.emptyLocatorArray(locatorArray) && this.label) {
                return this.label.getInnerElementFromSplitLocator(locatorArray);
            }
            return this.Super("getInnerElementFromSplitLocator", arguments);    
        }
    });
}



// DateChooser

if (isc.DateChooser) {
    
    // returns "/row[index]/col[index]"
    
    
    
    isc.DateChooser.addMethods({
        
        getInteriorLocator : function (element) {
            
            // We don't write any kind of unique DOM IDs or attrs to our buttons which
            // would simplify determining the purpose of the buttons except our click handler.
            
            // 2 possible approaches:
            // 1) Crudely look at the current cell position in whichever table its in - likely to 
            //    break if we rework ... wait a sec
            
            // Ok so playback / record type stuff
            // 
            // Lets say we store this as prevYear, prevMo, moLauncher, nextMo, nextYear and
            // dateCell[rowNum,colNum] and today, cancel
            
            // we can then get back the appropriate button when rerun
            // however if the default date has changed (which it likely will, tests are unlikely 
            // to work unless the user changes to a specific month first....
            
            
            // Alternative would be to remember dateCell[datestamp] - then we simply won't find the element if the date changes. Ok that seems better - won't get WRONG behavior
            
            // If we have a header, the event may have occurred in it
            var handle = this.getHandle();
            if (!handle || !element) return "";
            
            var cachedString = element._cachedLocatorString;
            if (cachedString != null && cachedString != "") return cachedString;
            
            return element._cachedLocatorString = this._getInteriorLocator(element, handle);
        },
        
        _getInteriorLocator : function (element, handle) {
            var targetCell = element;
            while (targetCell && targetCell != null) {
                if (targetCell == handle) {
                    targetCell = null;
                    break;
                }
                if (targetCell.tagName && targetCell.tagName.toLowerCase() == "td") {
                    break;
                }
                targetCell = targetCell.parentElement;
            }
            if (targetCell == null) return "";
            
            
            var childNodes = handle.childNodes,
                tables = [];
            for (var i = 0; i < childNodes.length; i++) {
                if (!childNodes[i].tagName || childNodes[i].tagName.toLowerCase() != "table") {
                    continue;
                }
                tables[tables.length] = childNodes[i];
            }
            
            var headerTable = tables.length == 2 ? tables[0] : null,
                bodyTable = tables.length == 2 ? tables[1] : tables[0];
            
            if (headerTable != null && targetCell.offsetParent == headerTable) {
                // could look at position within rows array -- but then we'd have to also
                // look at the various 'showMonthChooser' etc configurations -- instead
                // lets look directly at the onclick handler
                var clickFunction = targetCell.onclick,
                    clickFunctionString = clickFunction ? clickFunction.toString() : null;
                if (!clickFunctionString) return "";
                if (clickFunctionString.contains("showPrevYear")) {
                    return "prevYearButton";
                } else if (clickFunctionString.contains("showNextYear")) {
                    return "nextYearButton";
                } else if (clickFunctionString.contains("showPrevMonth")) {
                    return "prevMonthButton";
                } else if (clickFunctionString.contains("showNextMonth")) {
                    return "nextMonthButton";
                } else if (clickFunctionString.contains("showMonthMenu")) {
                    return "monthMenuButton";
                } else if (clickFunctionString.contains("showYearMenu")) {
                    return "yearMenuButton";
                }
                return "";
                
            } else if (bodyTable != null && targetCell.offsetParent == bodyTable) {
                // If the event was in the body, return the appropriate dateClick string
                var clickFunction = targetCell.onclick,
                    clickFunctionString = clickFunction ? clickFunction.toString() : null;
                if (!clickFunctionString) return "";
                
                if (clickFunctionString.contains("cancelClick")) return "cancelButton";
                else if (clickFunctionString.contains("todayClick")) return "todayButton";
                else {
                    var dateClick = clickFunctionString.match("dateClick\\(\(.*\)\\)");
                    if (dateClick && dateClick[1]) {
                        var dateArr = dateClick[1].split(",");
                        for (var i = 0; i < dateArr.length; i++) {
                            dateArr[i] = dateArr[i].trim();
                        }        
                        return dateArr.join("/");
                    }
                }
            }
            return "";
        },
        
        
        getInnerElementFromSplitLocator : function (locatorArray) {

            if (this.emptyLocatorArray(locatorArray)) return this.getHandle();

            var handle = this.getHandle();
            if (handle == null) return;
            
            var isDateButton = (locatorArray.length == 3);
            if (!isDateButton) {
                
                var locatorString = locatorArray[0];
                
                if (locatorString == "") return handle;
                
                var isTodayButton = (locatorString == "todayButton"),
                    isCancelButton = !isTodayButton ? (locatorString == "cancelButton") : false;
                    
                var childNodes = handle.childNodes;
                    
                // today / cancel button show up in the "body" table
                if (isTodayButton || isCancelButton) {
                        
                    if (isTodayButton && !this.showTodayButton) {
                        this.logWarn("DateChooser attempting to locate element for " +
                            "'todayButton' but showTodayButton is false. Returning handle.",
                            "AutoTest");
                        return handle;
                    }
                    if (isCancelButton && !this.showCancelButton) {
                        this.logWarn("DateChooser attempting to locate element for " +
                            "'cancelButton' but showCancelButton is false. Returning handle.",
                            "AutoTest");
                        return handle;
                    }
                    
                    var bodyTable;
                    // we show two tables if the header is showing, or just one if not.
                    // Either way the table we want is the last table in the handle.
                    for (var i = childNodes.length-1; i >= 0; i--) {
                        if (childNodes[i].tagName && 
                             childNodes[i].tagName.toLowerCase() == "table") 
                        {
                            bodyTable = childNodes[i];
                            break;
                        }
                    }
                    
                    // today/cancel button cells are in the last row of the table
                    var lastRow = bodyTable.rows[bodyTable.rows.length-1],
                        cells = lastRow.cells;
                    for (var i = 0; i < cells.length; i++) {
                        if (this.getInteriorLocator(cells[i]) == locatorString) {
                            return cells[i];
                        }
                    }
                    
                } else {
                    
                    // Other buttons show up in the header table
                    if (!this.showHeader) {
                        this.logWarn("DateChooser attempting to locate element for " + locatorArray +
                          " but this.showHeader is false so this element will not be present. " +
                          "Returning handle.", "AutoTest");
                        return handle;
                    }
                    
                    var headerTable
                        // we show two tables if the header is showing, so grab the first table in the
                        // childNodes array
                        for (var i = 0; i < childNodes.length; i++) {
                            if (childNodes[i].tagName && 
                                 childNodes[i].tagName.toLowerCase() == "table") 
                            {
                                headerTable = childNodes[i];
                                break;
                            }
                        }
                        
                        // controls show up in the first row of cells
                        var row = headerTable.rows[0],
                            cells = row.cells;
                        for (var i = 0; i < cells.length; i++) {
                             if (this.getInteriorLocator(cells[i]) == locatorString) {
                                return cells[i];
                            }
                        }
                }
                    

            // Date Buttons. Only releveant if we're showing the date in question!
            } else {
                
                // If we're showing a different year, obviously we're not showing the date button
                var year = locatorArray[0],
                    month = locatorArray[1],
                    date = locatorArray[2];
                    
                // month may differ but only for the few 'spillover' days at the beginning/end
                // of the week - so if the month is off by more than one we're not showing the
                // button
                if ((year == this.year) &&
                        (this.month == month || this.month == month+1 || this.month == month-1))
                {
                    // We could iterate through all the visible buttons looking at locators and
                    // see if they match, or we could figure out the rowNum/colNum in which
                    // the date will be showing (if it is) and pick the cell that way.
                    // We'll take the second approach
                    var buttonDate = new Date(year,month,date),
                        buttonDay = buttonDate.getDay();
                        
                    // only continue if we're showing weekends, or the button doesn't fall on 
                    // a weekend
                    if (this.showWeekends || !Date.getWeekendDays().contains(buttonDay)) {
                        
                        // figure out the first date we have a cell for
                        var start = new Date(this.year, this.month, 1);
                            // go back to the first day of the week for the start date
                            
                            var startDay = start.getDay(),
                                startOffset = startDay + this.firstDayOfWeek -
                                            // start date may have a lower "day number"
                                            // (sun=0 thru sat=6) than firstDayOfWeek,
                                            // in which case we need to adjust back by a week
                                            (startDay < this.firstDayOfWeek ? 7 : 0);
                                              
                            start.setDate(start.getDate() - startOffset);
                                        

                        // if the date is earlier than the first cell we're showing, we
                        // don't have a cell for it
                        // (this != comparison checks for opposite case - where we should continue)
                        if (Date.compareDates(buttonDate, start) != 1) {
                            
                            // get a pointer to the last day in the visible month
                            var end = new Date(this.year, this.month+1, 1);
                            end.setTime(end.getTime() - 86400000);
                            
                            // note that we show a few extra buttons for rest of the week
                            // (potentially)
                            var endDOW = end.getDay(),
                                lastDOW = this.firstDayOfWeek + 6;
                            if (lastDOW > 6) lastDOW -= 7;
                            
                            var dayDelta = lastDOW > endDOW ? 
                                                lastDOW-endDOW : lastDOW+7 - endDOW;
                            if (dayDelta != 0) {
                                end.setTime(end.getTime() + (86400000*dayDelta));
                            }
                            
                            // if the buttonDate is <= 'end' we are showing a cell for it
                            if (Date.compareDates(buttonDate, end) != -1) {
                                
                                // rowNum will be day-delta between button date and first 
                                // visible date / 7

                                var rowNum = Math.floor( ((parseInt(date) + startOffset) / 7)) 
                                                           
                                // we always show day of week headers in the first row.
                                
                                rowNum += 1;
                                
                                var firstDay = this.firstDayOfWeek;
                                if (!this.showWeekends) {
                                    while (Date.getWeekendDays().contains(firstDay)) {
                                        firstDay += 1;
                                        if (firstDay == 7) firstDay = 0;
                                    }
                                }
                                var colNum = buttonDate.getDay() - (firstDay + startOffset);
                                if (colNum < 0) colNum += 7;
                                // adjust for 1-based dates vs zero-based colNums
                                colNum -= 1;
                                
                                // Ok - we have a rowNum/colNum
                                var childNodes = handle.childNodes,
                                    bodyTable;
                                // we show two tables if the header is showing, or just one if not.
                                // Either way the table we want is the last table in the handle.
                                for (var i = childNodes.length-1; i >= 0; i--) {
                                    if (childNodes[i].tagName && 
                                         childNodes[i].tagName.toLowerCase() == "table") 
                                    {
                                        bodyTable = childNodes[i];
                                        break;
                                    }
                                }                                
                                if (bodyTable) return bodyTable.rows[rowNum].cells[colNum];
                            } else {
                                this.logInfo("DateChooser Passed ID for a date after end. " +
                                    "end date:"+ [end.getFullYear(), end.getMonth(),
                                                    end.getDay()] +
                                    " vs:" + [year, month, date], "AutoTest");
                            }
                        } else {
                            this.logInfo("DateChooser Passed ID for a date before start date. " +
                            "startDate:"+ [start.getFullYear(), start.getMonth(), start.getDay()] +
                            " vs:" + [year, month, date], "AutoTest");
                        }
                    } else {
                        this.logInfo("DateChooser Passed ID for a weekend - not showing weekends", "AutoTest");
                    }
                } else {
                    this.logInfo("DateChooser passed ID for the wrong year or month - passed:" + 
                        locatorArray + ", showing:" + [this.year,this.month], "AutoTest");
                }
                
                this.logWarn("DateChooser - passed inner locator for date (" +
                            locatorArray.join("/") + ") -- not currently showing this date.",
                            "AutoTest");
            }
                        
            this.logWarn("DateChooser, unable to find element for inner locator:"+
                locatorArray + " returning handle");
            return handle;
        }
    });
}

}

// Hold off applying the AutoTest interface methods to widget classes until the page is done loading
// This ensures we don't depend on module load order
isc.Page.setEvent("load", "isc.ApplyAutoTestMethods()");


